[gd_scene load_steps=5 format=2]

[ext_resource path="res://components/dialog.tscn" type="PackedScene" id=1]

[sub_resource type="GDScript" id=1]
script/source = "extends Control

var message_box
var sequence
var current_index = -1
var running = false

var sprites = {}
var audio = {}

var wait_queue = []

var camera
var canvas_layer

signal sequence_finished

func _ready():
	self.message_box = $CanvasLayer/MessageBox
	self.message_box.hide(false)

func set_camera(camera):
	self.camera = camera

func set_sequence(sequence: Array):
	self.sequence = sequence

func start():
	self.reset()
	self.resume()

func resume():
	self.running = true
	self._advance_sequence()

func stop():
	self.running = false

func reset():
	self.running = false
	self.current_index = -1

func _advance_sequence():
	# clear wait
	$WaitTimer.stop()
	
	self.current_index += 1
	if (self.current_index < self.sequence.size()):
		self._execute_sequence(self.current_index)
	else:
		self.running = false
		emit_signal('sequence_finished')

func _execute_sequence(index: int):
	var entry = self.sequence[index]
	if (entry is Dictionary):
		match entry.command:
			'hide_message_box':
				self.message_box.hide()
			'show_message_box':
				self.message_box.show()
			'sprite':
				self.show_sprite(entry.options)
			'container':
				self.show_container(entry.options)
			'audio':
				self.play_audio(entry.options)
			_:
				push_error(\"invalid event command\")
				self._advance_sequence()
	elif (entry is String):
		self.show_text(entry)
	elif (entry is float):
		self.wait(entry)

func wait(length: float):
	$WaitTimer.wait_time = length
	$WaitTimer.start()

func show_text(text: String):
	var options = {}
	
	var separator_position = text.find(\"|\")
	if (separator_position > 0):
		var split_text = text.split('|')
		options['nameplate'] = {
			'name': split_text[0],
			'hue': self.message_box.get_nameplate_hue(split_text[0]),
		}
		text = split_text[1]
		
	self.message_box.show_text(text, options)

func play_audio(options: Dictionary):
	var audio
	var key = 'voice'
	if (options.has('key')): key = options.key
	
	if (options.action == \"voice\"):
		# Remove existing voice (with same key) beforehand
		if (self.audio.has(key)):
			self.audio[key].queue_free()
			$AudioContainer.remove_child(self.audio[key])
			self.audio.erase(key)
		# Create new AudioStreamPlayer
		audio = AudioStreamPlayer.new()
		audio.stream = load(options.src)
		audio.bus = \"Voice\"
		self.audio[key] = audio
		$AudioContainer.add_child(audio)
		audio.connect(\"finished\", self, \"_on_audio_finish\", ['voice', key])
		audio.play()
		print (\"next by audio play\")
		self._advance_sequence()
	elif (options.action == \"sfx\"):
		# Create new AudioStreamPlayer
		audio = AudioStreamPlayer.new()
		audio.stream = load(options.src)
		audio.bus = \"SFX\"
		self.audio[key] = audio
		$AudioContainer.add_child(audio)
		audio.connect(\"finished\", self, \"_on_audio_finish\", ['sfx', key])
		audio.play()
		print (\"next by audio play\")
		self._advance_sequence()

func _on_audio_finish(type: String, key: String):
	if (type == 'voice' || type == 'sfx'):
		self.audio[key].queue_free()
		$AudioContainer.remove_child(self.audio[key])
		self.audio.erase(key)

func show_container(options: Dictionary):
	var duration = 1; if options.has('duration'): duration = options.duration
	var delay = 0; if options.has('delay'): delay = options.delay
	var wait_for_animation = true; if (options.has('wait')): wait_for_animation = options.wait
	
	var container
	match (options.target):
		\"sprites\":
			container = $SpriteContainer
		\"background\":
			container = $BackgroundContainer
	
	if (options.action == \"move\"):
		if (options.has('scale')):
			$SpriteTween.interpolate_property(container, 'rect_scale', null, options.scale, duration, Tween.TRANS_LINEAR, Tween.EASE_OUT_IN, delay)
		if (options.has('rotation')):
			$SpriteTween.interpolate_property(container, 'rect_rotation', null, options.rotation, duration, Tween.TRANS_LINEAR, Tween.EASE_OUT_IN, delay)
		if (options.has('position')):
			$SpriteTween.interpolate_property(container, 'rect_position', null, options.position, duration, Tween.TRANS_LINEAR, Tween.EASE_OUT_IN, delay)
		if (wait_for_animation): self.wait_queue.push_back(container)
		$SpriteTween.start()
	elif (options.action == \"clear\"):
		$SpriteTween.remove(container)
	
	# Immediately advance if queue is empty
	if (self.wait_queue.size() == 0):
		print(\"next by zero wait queue show container\")
		self._advance_sequence()

func show_sprite(options: Dictionary):
	var sprite
	var duration = 1; if options.has('duration'): duration = options.duration
	var delay = 0; if options.has('delay'): delay = options.delay
	var wait_for_animation = true; if (options.has('wait')): wait_for_animation = options.wait
	
	if (options.action == \"show\"):
		# Remove existing image beforehand
		if (self.sprites.has(options.key)):
			self.sprites[options.key].queue_free()
			$BackgroundContainer.remove_child(self.sprites[options.key])
			$SpriteContainer.remove_child(self.sprites[options.key])
			self.sprites.erase(options.key)
		if (options.key.substr(0, 2) == 'bg'):
			# Create new TextureRect
			sprite = TextureRect.new()
			sprite.texture = load(options.src)
			sprite.expand = true
			sprite.stretch_mode = TextureRect.STRETCH_KEEP_ASPECT_COVERED
			sprite.mouse_filter = Control.MOUSE_FILTER_IGNORE
			sprite.set_size(Vector2(ProjectSettings.get_setting(\"display/window/size/width\"), ProjectSettings.get_setting(\"display/window/size/height\")))
		else:
			sprite = Sprite.new()
			sprite.texture = load(options.src)
			sprite.scale = Vector2(1, 1)
			if (options.has('z_index')):
				sprite.z_index = options.z_index
		sprite.set_position(options.position)
		sprite.modulate.a = 0
		if (options.key.substr(0, 2) == 'bg'):
			$BackgroundContainer.add_child(sprite)
		else:
			$SpriteContainer.add_child(sprite)
		self.sprites[options.key] = sprite
		$SpriteTween.interpolate_property(sprite, 'modulate:a', 0, 1, duration, Tween.TRANS_LINEAR, Tween.EASE_OUT_IN, delay)
		if (wait_for_animation): self.wait_queue.push_back(sprite)
		$SpriteTween.start()
	elif (options.action == \"hide\"):
		sprite = self.sprites[options.key]
		$SpriteTween.interpolate_property(sprite, 'modulate:a', 1, 0, duration, Tween.TRANS_LINEAR, Tween.EASE_OUT_IN, delay)
		if (wait_for_animation): self.wait_queue.push_back(sprite)
		$SpriteTween.start()
	elif (options.action == \"change\"):
		sprite = self.sprites[options.key]
		sprite.texture = load(options.src)
	elif (options.action == \"move\"):
		sprite = self.sprites[options.key]
		if (options.has('position')):
			$SpriteTween.interpolate_property(sprite, 'position', null, options.position, duration, Tween.TRANS_LINEAR, Tween.EASE_OUT_IN, delay)
		if (options.has('scale')):
			$SpriteTween.interpolate_property(sprite, 'scale', null, options.scale, duration, Tween.TRANS_LINEAR, Tween.EASE_OUT_IN, delay)
		if (wait_for_animation): self.wait_queue.push_back(sprite)
		$SpriteTween.start()
	elif (options.action == \"dim\" || options.action == \"light\"):
		var color = Color(\"#7c7c7c\")
		if (options.action == \"light\"): color = Color(\"#ffffff\")
		if (!options.has('duration')): duration = 0.2
		sprite = self.sprites[options.key]
		$SpriteTween.interpolate_property(sprite, 'modulate', null, color, duration, Tween.TRANS_LINEAR, Tween.EASE_OUT_IN, delay)
		if (wait_for_animation): self.wait_queue.push_back(sprite)
		$SpriteTween.start()
	elif (options.action == \"clear\"):
		$SpriteTween.remove(self.sprites[options.key])
	
	# Immediately advance if queue is empty
	if (self.wait_queue.size() == 0):
		print(\"next by zero wait queue show sprite\")
		self._advance_sequence()

func _on_next():
	if (self.running):
		# Cancel if queue is not empty
		if (self.wait_queue.size() > 0): return false
		
		print (\"next by next\")
		self._advance_sequence()

func _on_MessageBox_finished_tweening():
	if (self.wait_queue.size() == 0 && self.running):
		print (\"next by mbox finished tweening\")
		self._advance_sequence()

func _on_sprite_tween_completed(object, key):
	if (self.wait_queue.has(object)):
		self.wait_queue.erase(object)
		if (self.wait_queue.size() == 0 && self.running):
			print (\"next by sprite tween completed\")
			self._advance_sequence()

func _on_sprite_tween_all_completed():
	pass

func _on_WaitTimer_timeout():
	print (\"next by wait timeout\")
	self._advance_sequence()
"

[sub_resource type="ImageTexture" id=2]
size = Vector2( 1920, 1080 )

[sub_resource type="ImageTexture" id=3]
size = Vector2( 1900, 1080 )

[node name="EventProcessor" type="Control"]
script = SubResource( 1 )
__meta__ = {
"_edit_use_anchors_": false
}

[node name="BackgroundContainer" type="TextureRect" parent="."]
self_modulate = Color( 1, 1, 1, 0 )
anchor_left = 0.5
anchor_top = 0.5
anchor_right = 0.5
anchor_bottom = 0.5
rect_pivot_offset = Vector2( 960, 540 )
mouse_filter = 2
texture = SubResource( 2 )
__meta__ = {
"_edit_use_anchors_": false
}

[node name="SpriteContainer" type="TextureRect" parent="."]
self_modulate = Color( 1, 1, 1, 0 )
margin_right = 1920.0
margin_bottom = 1080.0
rect_pivot_offset = Vector2( 960, 540 )
mouse_filter = 2
texture = SubResource( 3 )
__meta__ = {
"_edit_use_anchors_": false
}

[node name="SpriteTween" type="Tween" parent="."]

[node name="AudioContainer" type="Node" parent="."]

[node name="VoiceStreamPlayer" type="AudioStreamPlayer" parent="AudioContainer"]

[node name="CanvasLayer" type="CanvasLayer" parent="."]

[node name="MessageBox" parent="CanvasLayer" instance=ExtResource( 1 )]

[node name="WaitTimer" type="Timer" parent="."]
one_shot = true
__meta__ = {
"_editor_description_": ""
}
[connection signal="tween_all_completed" from="SpriteTween" to="." method="_on_sprite_tween_all_completed"]
[connection signal="tween_completed" from="SpriteTween" to="." method="_on_sprite_tween_completed"]
[connection signal="finished_tweening" from="CanvasLayer/MessageBox" to="." method="_on_MessageBox_finished_tweening"]
[connection signal="next" from="CanvasLayer/MessageBox" to="." method="_on_next"]
[connection signal="timeout" from="WaitTimer" to="." method="_on_WaitTimer_timeout"]
