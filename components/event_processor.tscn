[gd_scene load_steps=8 format=2]

[ext_resource path="res://components/dialog.tscn" type="PackedScene" id=1]
[ext_resource path="res://fonts/montreal/Montreal.tres" type="DynamicFont" id=2]
[ext_resource path="res://images/dialog_sprite/dia_a2.png" type="Texture" id=3]
[ext_resource path="res://images/bg/izumito.png" type="Texture" id=4]

[sub_resource type="GDScript" id=1]
script/source = "extends Node

onready var message_box: Node = $MessageBoxUILayer/MessageBox
onready var display_container: Node = $EventDisplayLayer/DisplayContainer
onready var background_container: Node = $EventDisplayLayer/DisplayContainer/BackgroundContainer
onready var sprites_container: Node = $EventDisplayLayer/DisplayContainer/SpriteContainer
onready var audio_container: Node = $AudioContainer
onready var tweens_container: Node = $TweensContainer
onready var wait_timer: Timer = $WaitTimer

var camera
var sequence
var current_index = -1
var running = false
var active = false
var nextable = true

var sprites = {}
var audio = {}
var sprite_tweens = {}

var wait_queue = []

signal sequence_finished
signal sequence_paused
signal hover_on
signal hover_off

func _ready():
	self.message_box.hide(false)
	
	# debugging tools
	$EventDisplayLayer/SequenceIndexDisplay.visible = OS.is_debug_build()

func set_camera(new_camera):
	self.camera = new_camera

func set_sequence(new_sequence: Array):
	self.sequence = new_sequence

func make_tween(node: Node):
	var tween: Tween = Tween.new()
	tween.connect('tween_all_completed', self, '_on_sprite_tween_completed', [tween, node])
	self.tweens_container.add_child(tween)
	
	# register to container variable
	if !(self.sprite_tweens.has(node)):
		self.sprite_tweens[node] = [];
	self.sprite_tweens[node].append(tween)
	
	return tween 

func start():
	if OS.is_debug_build(): print('[EVPR] sequence started')
	
	self.reset()
	self.resume()

func resume():
	self.running = true
	self.active = true
	
	self._advance_sequence()

func pause():
	self.running = false
	if OS.is_debug_build(): print('[EVPR] sequence paused')
	emit_signal('sequence_paused')

func reset():
	self.running = false
	self.current_index = -1
	if OS.is_debug_build(): $EventDisplayLayer/SequenceIndexDisplay.set_text(String(self.current_index))
	self.active = false

func _advance_sequence():
	# clear wait
	self.wait_timer.stop()

	self.current_index += 1
	if OS.is_debug_build(): $EventDisplayLayer/SequenceIndexDisplay.set_text(String(self.current_index))
	
	# if there are still more to process
	if (self.current_index < self.sequence.size()):
		self._execute_sequence(self.current_index)
	# if end of sequence
	else:
		self.running = false
		self.active = false
		if OS.is_debug_build(): print('[EVPR] sequence finished')
		emit_signal('sequence_finished')

func _execute_sequence(index: int):
	if OS.is_debug_build(): print('[EVPR] executing sequence index ' + str(index))
	var entry = self.sequence[index]
	
	# array will be converetd to dictionary and be processed in the following if block
	if (entry is Array):
		entry = self.translate_shortcode(entry)
	
	if (entry is Dictionary):
		match entry.command:
			'hide_message_box':
				self.message_box.hide()
			'show_message_box':
				self.message_box.show()
			'sprite':
				self.show_sprite(entry.options)
			'container':
				self.show_container(entry.options)
			'audio':
				self.play_audio(entry.options)
			'pause_sequence':
				self.pause()
			_:
				push_error('invalid event command')
				self._advance_sequence()
	elif (entry is String):
		self.show_text(entry)
	elif (entry is float):
		self.wait(entry)
	elif (entry is FuncRef):
		entry.call_func()
		if OS.is_debug_build(): print('[EVPR] next by callable finish')
		self._advance_sequence()

func wait(length: float):
	self.wait_timer.wait_time = length
	self.wait_timer.start()

func show_text(text: String):
	var options = {}

	var separator_position = text.find('|')
	if (separator_position > 0):
		var split_text = text.split('|')
		
		var hue = 0
		var hue_separator_position = split_text[0].find('#')
		if (hue_separator_position > 0):
			var hue_split_text = split_text[0].split('#')
			hue = hue_split_text[1].to_float()
			split_text[0] = hue_split_text[0]
		
		options['nameplate'] = {
			'name': split_text[0],
			'hue': hue
		}
		text = split_text[1]

	self.message_box.show_text(text, options)

func play_audio(options: Dictionary):
	if (options.action == 'bgm'):
		# stop current BGM if different
		if (self.bgm_player.is_playing()):
			if (self.audio['bgm'] != options.src):
				self.bgm_player.stop()
			else:
				# cancel if same
				return
		self.bgm_player.stream = options.src if options.src is Resource else load(options.src)
		self.audio['bgm'] = options.src
		self.bgm_player.play()
		if OS.is_debug_build(): print('[EVPR] next by audio play (bgm)')
	elif (options.action == 'voice' || options.action == 'sfx'):
		# assign from options if given, or set default
		var key = options.action
		if (options.has('key')): key = options.key
		# remove existing audio (with same key) beforehand
		if (self.audio.has(key)):
			self.audio[key].queue_free()
			self.audio_container.remove_child(self.audio[key])
			self.audio.erase(key)
		# create new AudioStreamPlayer
		var new_audio = AudioStreamPlayer.new()
		new_audio.stream = options.src if options.src is Resource else load(options.src)
		match (options.action):
			'voice': new_audio.bus = 'Voice'
			'sfx': new_audio.bus = 'SFX'
		self.audio[key] = new_audio
		self.audio_container.add_child(new_audio)
		new_audio.connect('finished', self, '_on_audio_finish', [options.action, key])
		new_audio.play()
		if OS.is_debug_build(): print('[EVPR] next by audio play (' + options.action + ')')
	else:
		push_warning('invalid audio action: ' + options.action)
	self._advance_sequence()

func _on_audio_finish(type: String, key: String):
	if (type == 'voice' || type == 'sfx'):
		self.audio[key].queue_free()
		self.audio_container.remove_child(self.audio[key])
		self.audio.erase(key)

func show_container(options: Dictionary):
	var target
	match (options.key):
		'sprites':
			target = self.sprites_container
		'background', 'bg':
			target = self.background_container
	
	self._manipulate_sprite(target, options)

func show_sprite(options: Dictionary):
	var sprite: Node
	
	# if new (by create or take) sprite
	if (options.action == 'show' || options.action == 'take'):
		# remove existing one beforehand
		if (self.sprites.has(options.key)):
			self.sprites[options.key].queue_free()
			if (options.key.substr(0, 2) == 'bg'):
				self.background_container.remove_child(self.sprites[options.key])
			else:
				self.sprites_container.remove_child(self.sprites[options.key])
			self.sprites.erase(options.key)
		# create new sprite
		if (options.action == 'show'):
			sprite = TextureRect.new()
			sprite.texture = options.src if options.src is Resource else load(options.src)
			sprite.mouse_filter = Control.MOUSE_FILTER_IGNORE
			if (options.key.substr(0, 2) == 'bg'):
				sprite.stretch_mode = TextureRect.STRETCH_KEEP_ASPECT_COVERED
				sprite.expand = false
				sprite.rect_size = Vector2(int(ProjectSettings.get_setting('display/window/size/width')), int(ProjectSettings.get_setting('display/window/size/height')))
			else:
				sprite.stretch_mode = TextureRect.STRETCH_KEEP_ASPECT_CENTERED
				sprite.expand = true
				sprite.rect_min_size.x = sprite.texture.get_width()
				sprite.rect_min_size.y = min(sprite.texture.get_height(), int(ProjectSettings.get_setting('display/window/size/height')))
				sprite.set_pivot_offset(Vector2(sprite.rect_min_size.x / 2, sprite.rect_min_size.y / 2))
			if (options.has('scale')):
				sprite.rect_scale = options.scale
			else:
				sprite.rect_scale = Vector2(1, 1)
			#if (options.has('z_index')):
				#sprite.z_index = options.z_index
			if (options.has('position')):
				sprite.rect_position = self.calculate_position(sprite, options.position)
			sprite.modulate.a = 0 # start invisible
		# take existing sprite
		elif (options.action == 'take'):
			sprite = options.node
			sprite.modulate.a = 0
			sprite.visible = true
			(sprite.get_parent()).remove_child(sprite)
		
		# add to container
		if (options.key.substr(0, 2) == 'bg'):
			# add to bg container
			self.background_container.add_child(sprite)
		else:
			# add to sprite contianer
			self.sprites_container.add_child(sprite)
		# register sprite to collection
		self.sprites[options.key] = sprite
	# if manipulating existing sprite
	else:
		sprite = self.sprites[options.key]
	
	self._manipulate_sprite(sprite, options)

func calculate_position(sprite: Node, new_position: Vector2):
	# only applies to control nodes
	if (!(sprite is Control)): return new_position
	var pivot_offset = sprite.get_pivot_offset()
	return Vector2(new_position.x - pivot_offset.x, new_position.y - pivot_offset.y)

func _manipulate_sprite(target: Node, options: Dictionary):
	var duration = 1; if options.has('duration'): duration = options.duration
	var delay = 0; if options.has('delay'): delay = options.delay
	var wait_for_animation = true; if (options.has('wait')): wait_for_animation = options.wait
	
	match options.action:
		'show', 'hide':
			# interpolate visibility
			var tween = self.make_tween(target)
			tween.interpolate_property(target, 'modulate:a', target.modulate.a, (1 if options.action == 'show' else 0), duration, Tween.TRANS_LINEAR, Tween.EASE_OUT_IN, delay)
			if (wait_for_animation): self.wait_queue.push_back(tween)
			tween.start()
		'change':
			if (!(target is TextureRect) && !(target is Sprite)): push_error('\"Change\" event called on invalid type')
			target.texture = options.src if options.src is Resource else load(options.src)
		'move':
			# move according to options
			var tween = self.make_tween(target)
			if (options.has('scale')):
				tween.interpolate_property(target, 'rect_scale' if target is Control else 'scale', target.rect_scale if target is Control else target.scale, options.scale, duration, Tween.TRANS_LINEAR, Tween.EASE_OUT_IN, delay)
			if (options.has('rotation')):
				tween.interpolate_property(target, 'rect_rotation' if target is Control  else 'rotation', target.rect_rotation if target is Control else target.rotation, options.rotation, duration, Tween.TRANS_LINEAR, Tween.EASE_OUT_IN, delay)
			if (options.has('position')):
				tween.interpolate_property(target, 'rect_position' if target is Control  else 'position', target.rect_position if target is Control else target.position, self.calculate_position(target, options.position), duration, Tween.TRANS_LINEAR, Tween.EASE_OUT_IN, delay)
			if (options.has('opacity')):
				tween.interpolate_property(target, 'modulate:a', target.modulate.a, options.opacity, duration, Tween.TRANS_LINEAR, Tween.EASE_OUT_IN, delay)
			if (wait_for_animation): self.wait_queue.push_back(tween)
			tween.start()
		'dim', 'light':
			var color = Color('#7c7c7c')
			if (options.action == 'light'): color = Color('#ffffff')
			if (!options.has('duration')): duration = 0.2 # minimum duration
			# keep opacity
			var alpha = target.modulate.a
			color.a = alpha
			var tween = self.make_tween(target)
			tween.interpolate_property(target, 'modulate', target.modulate, color, duration, Tween.TRANS_LINEAR, Tween.EASE_OUT_IN, delay)
			if (wait_for_animation): self.wait_queue.push_back(tween)
			tween.start()
		'stop':
			for tween in self.sprite_tweens[target]: tween.stop_all()
		'resume':
			for tween in self.sprite_tweens[target]: tween.resume_all()
		'clear':
			for tween in self.sprite_tweens[target]: tween.remove_all()
			self.sprite_tweens[target].clear()
		'reset':
			target.rect_scale = Vector2(1, 1)
			target.rect_rotation = 0
			target.rect_position = Vector2(0, 0)
		'remove':
			target.queue_free()
	
	# immediately advance if queue is empty
	if (self.wait_queue.size() == 0):
		if OS.is_debug_build(): print('[EVPR] next by zero wait queue show sprite/container')
		self._advance_sequence()

func translate_shortcode(shortcode: Array):
	var command: String = shortcode[0]
	var options: Dictionary
	var translated: Dictionary

	if (!command.begins_with('>')): push_error(\"Shortcode string didn't start with '>'.\")
	if (shortcode.size() == 2):
		options = shortcode[1]

	# main command
	var split_command: Array = command.split('|')
	translated = { 'command': split_command[0].trim_prefix('>') }

	# options (action & key)
	if (split_command.size() > 1):
		options.action = split_command[1]
		translated.options = options
		if (split_command.size() >= 3):
			translated.options.key = split_command[2]
	# additional options (skip wait)
	if (split_command.size() >= 4):
		if (translated.command != 'voice'):
			if (split_command[3] == 'nowait'):
				translated.options.wait = false
			elif (split_command[3] == 'wait'):
				translated.options.wait = true

	return translated

func _on_next(sender = null):
	if (self.running && self.nextable):
		# cancel if queue is not empty
		if (self.wait_queue.size() > 0): return false

		if OS.is_debug_build(): print('[EVPR] next by next')
		self._advance_sequence()

func _on_MessageBox_finished_typing(tags = null):
	if ('no_confirmation' in tags):
		self._advance_sequence()

func _on_MessageBox_finished_tweening():
	if (self.wait_queue.size() == 0 && self.running):
		if OS.is_debug_build(): print('[EVPR] next by mbox finished tweening')
		self._advance_sequence()

func _on_sprite_tween_completed(tween: Tween, node: Node):
	# remove from tween registry
	self.sprite_tweens[node].erase(tween)
	# delete tween
	tween.queue_free()
	
	if (self.wait_queue.has(tween)):
		self.wait_queue.erase(tween)
		if (self.wait_queue.size() == 0 && self.running):
			if OS.is_debug_build(): print('[EVPR] next by sprite tween completed')
			self._advance_sequence()

func _on_WaitTimer_timeout():
	if OS.is_debug_build(): print('[EVPR] next by wait timeout')
	self._advance_sequence()

func _on_hover(emitter): emit_signal('hover_on', emitter)
func _off_hover(emitter): emit_signal('hover_off', emitter)
"

[sub_resource type="ImageTexture" id=2]
size = Vector2( 1920, 1080 )

[sub_resource type="ImageTexture" id=3]
size = Vector2( 1900, 1080 )

[node name="EventProcessor" type="Node"]
script = SubResource( 1 )

[node name="EventDisplayLayer" type="CanvasLayer" parent="."]

[node name="DisplayContainer" type="Sprite" parent="EventDisplayLayer"]

[node name="BackgroundContainer" type="TextureRect" parent="EventDisplayLayer/DisplayContainer"]
self_modulate = Color( 1, 1, 1, 0 )
anchor_left = 0.5
anchor_top = 0.5
anchor_right = 0.5
anchor_bottom = 0.86
margin_left = -0.5
margin_top = -0.5
margin_right = 1919.5
margin_bottom = 1079.5
rect_pivot_offset = Vector2( 960, 540 )
mouse_filter = 2
texture = SubResource( 2 )
__meta__ = {
"_edit_use_anchors_": false
}

[node name="TextureRect" type="TextureRect" parent="EventDisplayLayer/DisplayContainer/BackgroundContainer"]
visible = false
margin_right = 1920.0
margin_bottom = 1280.0
texture = ExtResource( 4 )
stretch_mode = 7
__meta__ = {
"_edit_use_anchors_": false
}

[node name="SpriteContainer" type="TextureRect" parent="EventDisplayLayer/DisplayContainer"]
self_modulate = Color( 1, 1, 1, 0 )
margin_right = 1920.0
margin_bottom = 1080.0
rect_pivot_offset = Vector2( 960, 540 )
mouse_filter = 2
texture = SubResource( 3 )
__meta__ = {
"_edit_use_anchors_": false
}

[node name="TextureRect" type="TextureRect" parent="EventDisplayLayer/DisplayContainer/SpriteContainer"]
visible = false
margin_left = 960.0
margin_right = 1560.0
margin_bottom = 1080.0
rect_pivot_offset = Vector2( 300, 540 )
texture = ExtResource( 3 )
expand = true
stretch_mode = 6
__meta__ = {
"_edit_use_anchors_": false
}

[node name="SequenceIndexDisplay" type="Label" parent="EventDisplayLayer"]
margin_right = 40.0
margin_bottom = 56.0
custom_colors/font_color = Color( 1, 0, 0, 1 )
custom_colors/font_color_shadow = Color( 0, 0, 0, 1 )
custom_constants/shadow_offset_x = 4
custom_fonts/font = ExtResource( 2 )
text = "0"
__meta__ = {
"_edit_use_anchors_": false
}

[node name="AudioContainer" type="Node" parent="."]

[node name="BGMPlayer" type="AudioStreamPlayer" parent="AudioContainer"]
bus = "BGM"

[node name="TweensContainer" type="Node" parent="."]

[node name="MessageBoxUILayer" type="CanvasLayer" parent="."]

[node name="MessageBox" parent="MessageBoxUILayer" instance=ExtResource( 1 )]
visible = false

[node name="WaitTimer" type="Timer" parent="."]
one_shot = true
__meta__ = {
"_editor_description_": ""
}

[connection signal="finished_tweening" from="MessageBoxUILayer/MessageBox" to="." method="_on_MessageBox_finished_tweening"]
[connection signal="finished_typing" from="MessageBoxUILayer/MessageBox" to="." method="_on_MessageBox_finished_typing"]
[connection signal="hover_off" from="MessageBoxUILayer/MessageBox" to="." method="_off_hover" binds= [ "MessageBox" ]]
[connection signal="hover_on" from="MessageBoxUILayer/MessageBox" to="." method="_on_hover" binds= [ "MessageBox" ]]
[connection signal="next" from="MessageBoxUILayer/MessageBox" to="." method="_on_next" binds= [ "message_box" ]]
[connection signal="timeout" from="WaitTimer" to="." method="_on_WaitTimer_timeout"]
